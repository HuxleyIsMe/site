const response = {
  creator: "Huxley Millard",
  title: "Let’s talk JS Asynchronicity and promises in JS: Part 1",
  link: "https://medium.com/@huxley.millard/lets-talk-js-asynchronicity-and-promises-in-js-part-1-36f34155826c?source=rss-258d9bdc9207------2",
  pubDate: "Wed, 16 Apr 2025 15:30:33 GMT",
  "content:encoded":
    '<p>Today, we’re going to take a look at Promises: What are they? What problem are they trying to solve? And what the heck is asynchronous programming?</p><h3>What is a Promise?</h3><p>In human terms, a <strong>Promise</strong> is like an agreement: “I’ll do something for you later, just trust me.” In JavaScript, it’s similar: we’re telling our code that we’ll complete a task later. Unlike me promising to do the dishes, JavaScript <strong>will</strong> actually do them later if it promises.</p><h3>What Problem are Promises Trying to Solve?</h3><p>Promises allow us to work in an async manner meaning are program can continue to function without being slowed or blocked by having to wait for a longer running task. When we refer to sync and async code we usually refer to blocking and non blocking code, synchronous code will block the further execution of further code unlike asynchronous.</p><p>JS works in a sync fashion, it steps through doing one action at a time. If we wern’t able to leverage async techniques we would have to hold and wait the execution of our code while we wait for a step to complete. Doing one action at a time one step after the next. I think that the intro to the 2022 AWS tech summit did a great visualisation of what living in a synchronous world could look like:<br><a href="https://aws.amazon.com/awstv/watch/1fa141ec9ed/">https://aws.amazon.com/awstv/watch/1fa141ec9ed/</a></p><h3>Why is Asynchronous Important?</h3><p>JavaScript is <strong>synchronous</strong> by default — it steps through actions one at a time. If we didn’t use <strong>async</strong> techniques, we’d have to wait for each task to finish before moving on to the next one. This would make things incredibly slow and frustrating. An important thing to grasp here is Async is a concept, and we as a community have created ways for our programs to work in async manner.</p><p>Imagine trying to cook dinner in a <strong>synchronous world</strong> where you can’t chop vegetables until the pan is hot, you can’t stir the sauce while blending, and you certainly can’t cook the pasta while your bolognese is on the stove. It’s inefficient, right?</p><p>Some mission-critical systems, like a surgeon performing brain surgery, do prefer <strong>synchronous</strong> methods over <strong>async</strong>, because you’d want your brain surgeon solely focused on the task at hand and not multitasking.</p><p>But for everyday JavaScript tasks, <strong>Promises</strong> let us multitask and make better use of our time.</p><h3>How does JS leverage Async and where are promises involved?</h3><p>Unlike other languages like <strong>Java</strong>, JavaScript works on <strong>one thread</strong>. This means it can only do one thing at a time however it can leverage async concepts through the use of its event loop and underlying structure, effecitively allowing it to multitask.</p><p>Here’s how it works behind the scenes, the key components are:</p><ul><li><strong>Call Stack</strong>: Where the functions are executed.</li><li><strong>Web APIs/Table</strong>: Where asynchronous tasks like setTimeout or fetch are handled.</li><li><strong>Microtask Queue</strong>: Where the results of promises wait to be seen</li><li><strong>Macro Task Queue</strong>: Where other tasks like setTimeout are placed.</li><li><strong>Event Loop</strong>: The magical runner that processes all of this.</li></ul><p>I recommend a watch of this series here:</p><p><a href="https://www.youtube.com/watch?v=-G9c4CMMUKc">https://www.youtube.com/watch?v=-G9c4CMMUKc</a></p><p>Else in the next part of this series Iwill take us through the JS event loop, building our own faux version. Once we have some familiarity on that we will be able to take our understanding of promises a little deeper.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=36f34155826c" width="1" height="1" alt="">',
  "content:encodedSnippet":
    "Today, we’re going to take a look at Promises: What are they? What problem are they trying to solve? And what the heck is asynchronous programming?\nWhat is a Promise?\nIn human terms, a Promise is like an agreement: “I’ll do something for you later, just trust me.” In JavaScript, it’s similar: we’re telling our code that we’ll complete a task later. Unlike me promising to do the dishes, JavaScript will actually do them later if it promises.\nWhat Problem are Promises Trying to Solve?\nPromises allow us to work in an async manner meaning are program can continue to function without being slowed or blocked by having to wait for a longer running task. When we refer to sync and async code we usually refer to blocking and non blocking code, synchronous code will block the further execution of further code unlike asynchronous.\nJS works in a sync fashion, it steps through doing one action at a time. If we wern’t able to leverage async techniques we would have to hold and wait the execution of our code while we wait for a step to complete. Doing one action at a time one step after the next. I think that the intro to the 2022 AWS tech summit did a great visualisation of what living in a synchronous world could look like:\nhttps://aws.amazon.com/awstv/watch/1fa141ec9ed/\nWhy is Asynchronous Important?\nJavaScript is synchronous by default — it steps through actions one at a time. If we didn’t use async techniques, we’d have to wait for each task to finish before moving on to the next one. This would make things incredibly slow and frustrating. An important thing to grasp here is Async is a concept, and we as a community have created ways for our programs to work in async manner.\nImagine trying to cook dinner in a synchronous world where you can’t chop vegetables until the pan is hot, you can’t stir the sauce while blending, and you certainly can’t cook the pasta while your bolognese is on the stove. It’s inefficient, right?\nSome mission-critical systems, like a surgeon performing brain surgery, do prefer synchronous methods over async, because you’d want your brain surgeon solely focused on the task at hand and not multitasking.\nBut for everyday JavaScript tasks, Promises let us multitask and make better use of our time.\nHow does JS leverage Async and where are promises involved?\nUnlike other languages like Java, JavaScript works on one thread. This means it can only do one thing at a time however it can leverage async concepts through the use of its event loop and underlying structure, effecitively allowing it to multitask.\nHere’s how it works behind the scenes, the key components are:\n\nCall Stack: Where the functions are executed.\nWeb APIs/Table: Where asynchronous tasks like setTimeout or fetch are handled.\nMicrotask Queue: Where the results of promises wait to be seen\nMacro Task Queue: Where other tasks like setTimeout are placed.\nEvent Loop: The magical runner that processes all of this.\n\nI recommend a watch of this series here:\nhttps://www.youtube.com/watch?v=-G9c4CMMUKc\nElse in the next part of this series Iwill take us through the JS event loop, building our own faux version. Once we have some familiarity on that we will be able to take our understanding of promises a little deeper.",
  "dc:creator": "Huxley Millard",
  guid: "https://medium.com/p/36f34155826c",
  categories: ["asynchronous", "promises", "javascript"],
  isoDate: "2025-04-16T15:30:33.000Z",
};

export type MediumArticle = typeof response;
